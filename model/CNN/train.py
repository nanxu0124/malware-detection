import sys
import os
current_dir = os.path.dirname(__file__)
project_dir = os.path.abspath(os.path.join(current_dir, '../..'))
sys.path.append(project_dir)


from utils import utils

import torch
from tqdm import tqdm
from sklearn.metrics import recall_score, f1_score, accuracy_score

CNNModel_losses = []

def train_CNNModel(model, train_loader, criterion, optimizer, num_epochs, folder_path):

    print('CNNModel Training begin')
    for epoch in range(num_epochs):
        model.train()
        running_loss = 0.0
        true_labels = []
        predicted_labels = []

        for inputs, labels in tqdm(train_loader, desc=f'Epoch {epoch + 1}/{num_epochs}', ncols=100):

            # 设置device
            inputs = inputs.to(utils.device())
            labels = labels.to(utils.device())

            # 清零梯度
            optimizer.zero_grad()

            # 正向传播
            outputs = model(inputs)
            loss = criterion(outputs, labels)

            # 反向传播和优化
            loss.backward()
            optimizer.step()

            # 计算损失
            running_loss += loss.item()

            # 保存真实标签和预测标签以计算指标
            true_labels.extend(labels.tolist())
            _, predicted = torch.max(outputs, 1)
            predicted_labels.extend(predicted.tolist())

        # 计算本次 epoch 的平均损失
        avg_loss = running_loss / len(train_loader)

        # 保存所有 epoch 的损失
        CNNModel_losses.append(avg_loss)

        # 计算召回率、F1-Score 和准确度
        recall = recall_score(true_labels, predicted_labels, average='weighted')
        f1 = f1_score(true_labels, predicted_labels, average='weighted')
        accuracy = accuracy_score(true_labels, predicted_labels)

        # 输出本次 epoch 的指标
        print(f'Epoch [{epoch + 1}/{num_epochs}] - Loss: {avg_loss:.4f} - Recall: {recall:.4f} - F1-Score: {f1:.4f} - Accuracy: {accuracy:.4f}')

    utils.model_save(folder_path, (model,))

    print('CNNModel Training finished')

    return CNNModel_losses


def test(cnnModel, test_loader):

    # 设置模型为评估模式
    cnnModel.eval()

    true_labels = []
    predicted_labels = []

    with torch.no_grad():  # 不需要计算梯度
        for inputs, labels in test_loader:

            # 设置device
            inputs = inputs.to(utils.device())
            labels = labels.to(utils.device())

            # 获取模型输出结果
            outputs = cnnModel(inputs)

            _, predicted = torch.max(outputs, 1)
            
            # 保存真实标签和预测标签以计算指标
            true_labels.extend(labels.tolist())
            predicted_labels.extend(predicted.tolist())

    # 计算召回率、F1-Score 和准确度
    recall = recall_score(true_labels, predicted_labels, average='weighted')
    f1 = f1_score(true_labels, predicted_labels, average='weighted')
    accuracy = accuracy_score(true_labels, predicted_labels)

    # 输出测试指标
    print(f'Test Accuracy: {accuracy:.4f}')
    print(f'Test Recall: {recall:.4f}')
    print(f'Test F1-Score: {f1:.4f}')

    return recall, f1, accuracy